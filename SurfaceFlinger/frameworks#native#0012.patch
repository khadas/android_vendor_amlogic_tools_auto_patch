From 4c6de2a0acd3b4258600fa195227c31046747cca Mon Sep 17 00:00:00 2001
From: sky zhou <sky.zhou@amlogic.com>
Date: Tue, 30 Jul 2019 20:55:32 +0800
Subject: [PATCH] SurfaceFlinger: update hdr caps when hotplug [1/2]

PD#SWPL-8230

Problem:
HDR caps is not updated when new connector connected.

Solution:
update hdr when hotplug

Verify:
Verify by franklin.

Change-Id: I46a09c5f4e14d54f4ee9f9eb2069036333a16dd7
Signed-off-by: sky zhou <sky.zhou@amlogic.com>
---
 services/surfaceflinger/DisplayDevice.cpp  | 10 +++++++---
 services/surfaceflinger/DisplayDevice.h    |  2 ++
 services/surfaceflinger/SurfaceFlinger.cpp |  4 ++++
 3 files changed, 13 insertions(+), 3 deletions(-)

diff --git a/services/surfaceflinger/DisplayDevice.cpp b/services/surfaceflinger/DisplayDevice.cpp
index db095a5..355b568 100644
--- a/services/surfaceflinger/DisplayDevice.cpp
+++ b/services/surfaceflinger/DisplayDevice.cpp
@@ -257,6 +257,13 @@ DisplayDevice::DisplayDevice(
     // clang-format on
     populateColorModes(hwcColorModes);
 
+    updateHdrCapabilities(hdrCapabilities);
+
+    // initialize the display orientation transform.
+    setProjection(DisplayState::eOrientationDefault, mViewport, mFrame);
+}
+
+void DisplayDevice::updateHdrCapabilities(const HdrCapabilities& hdrCapabilities) {
     std::vector<Hdr> types = hdrCapabilities.getSupportedHdrTypes();
     for (Hdr hdrType : types) {
         switch (hdrType) {
@@ -293,9 +300,6 @@ DisplayDevice::DisplayDevice(
         }
     }
     mHdrCapabilities = HdrCapabilities(types, maxLuminance, maxAverageLuminance, minLuminance);
-
-    // initialize the display orientation transform.
-    setProjection(DisplayState::eOrientationDefault, mViewport, mFrame);
 }
 
 DisplayDevice::~DisplayDevice() = default;
diff --git a/services/surfaceflinger/DisplayDevice.h b/services/surfaceflinger/DisplayDevice.h
index 6c3bd91..27bd6fd 100644
--- a/services/surfaceflinger/DisplayDevice.h
+++ b/services/surfaceflinger/DisplayDevice.h
@@ -144,6 +144,8 @@ public:
     status_t beginFrame(bool mustRecompose) const;
     status_t prepareFrame(HWComposer& hwc);
 
+    void updateHdrCapabilities(const HdrCapabilities& hdrCapabilities);
+
     bool hasWideColorGamut() const { return mHasWideColorGamut; }
     // Whether h/w composer has native support for specific HDR type.
     bool hasHDR10Support() const { return mHasHdr10; }
diff --git a/services/surfaceflinger/SurfaceFlinger.cpp b/services/surfaceflinger/SurfaceFlinger.cpp
index 53e22c8..b2973ee 100644
--- a/services/surfaceflinger/SurfaceFlinger.cpp
+++ b/services/surfaceflinger/SurfaceFlinger.cpp
@@ -2605,6 +2605,10 @@ void SurfaceFlinger::handleTransactionLocked(uint32_t transactionFlags)
 #ifdef USE_AML_HW_ACTIVE_MODE
         // deal Primary display hotplug
         if (transactionFlags & ePrimaryHotplugTranscation) {
+            HdrCapabilities hdrCapabilities;
+            const sp<DisplayDevice>& displayDevice(mDisplays[DisplayDevice::DISPLAY_PRIMARY]);
+            getHwComposer().getHdrCapabilities(displayDevice->getHwcDisplayId(), &hdrCapabilities);
+            displayDevice->updateHdrCapabilities(hdrCapabilities);
             mEventThread->onHotplugReceived(DisplayDevice::DISPLAY_PRIMARY, true);
         }
 #endif
-- 
2.7.4

