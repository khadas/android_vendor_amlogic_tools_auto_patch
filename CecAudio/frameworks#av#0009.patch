From 82cfcebb05724ee9dd850d39e92520c54807f1d8 Mon Sep 17 00:00:00 2001
From: Eric Laurent <elaurent@google.com>
Date: Tue, 29 Jan 2019 14:25:04 -0800
Subject: [PATCH] audio policy: remove glitch when registering dynamic policies

Bypass systematic playback client route evaluation when connecting a
remote submix output device used by a recorder dysnamic policy as no
rerouting is needed in this case.

Bug: 115429872
Test: play music with GPM on Android TV and use the BLE remote
Change-Id: I368295d6617fe5ce98aac78ebce8b9f04c5e3695
---
 .../managerdefault/AudioPolicyManager.cpp          | 52 +++++++++++++++-------
 1 file changed, 36 insertions(+), 16 deletions(-)

diff --git a/services/audiopolicy/managerdefault/AudioPolicyManager.cpp b/services/audiopolicy/managerdefault/AudioPolicyManager.cpp
index 558da78..1b64e6c 100644
--- a/services/audiopolicy/managerdefault/AudioPolicyManager.cpp
+++ b/services/audiopolicy/managerdefault/AudioPolicyManager.cpp
@@ -211,24 +211,44 @@ status_t AudioPolicyManager::setDeviceConnectionStateInt(audio_devices_t device,
             return BAD_VALUE;
         }
 
-        checkForDeviceAndOutputChanges([&]() {
-            // outputs must be closed after checkOutputForAllStrategies() is executed
-            if (!outputs.isEmpty()) {
-                for (audio_io_handle_t output : outputs) {
-                    sp<SwAudioOutputDescriptor> desc = mOutputs.valueFor(output);
-                    // close unused outputs after device disconnection or direct outputs that have been
-                    // opened by checkOutputsForDevice() to query dynamic parameters
-                    if ((state == AUDIO_POLICY_DEVICE_STATE_UNAVAILABLE) ||
-                            (((desc->mFlags & AUDIO_OUTPUT_FLAG_DIRECT) != 0) &&
-                             (desc->mDirectOpenCount == 0))) {
-                        closeOutput(output);
-                    }
+        // No need to evaluate playback routing when connecting a remote submix
+        // output device used by a dynamic policy of type recorder as no
+        // playback use case is affected.
+        bool doCheckForDeviceAndOutputChanges = true;
+        if (device == AUDIO_DEVICE_OUT_REMOTE_SUBMIX
+                && strncmp(device_address, "0", AUDIO_DEVICE_MAX_ADDRESS_LEN) != 0) {
+            for (audio_io_handle_t output : outputs) {
+                sp<SwAudioOutputDescriptor> desc = mOutputs.valueFor(output);
+                if (desc->mPolicyMix != nullptr
+                        && desc->mPolicyMix->mMixType == MIX_TYPE_RECORDERS
+                        && strncmp(device_address,
+                                   desc->mPolicyMix->mDeviceAddress.string(),
+                                   AUDIO_DEVICE_MAX_ADDRESS_LEN) == 0) {
+                    doCheckForDeviceAndOutputChanges = false;
+                    break;
                 }
-                // check A2DP again after closing A2DP output to reset mA2dpSuspended if needed
-                return true;
             }
-            return false;
-        });
+        }
+        if (doCheckForDeviceAndOutputChanges) {
+          checkForDeviceAndOutputChanges([&]() {
+              // outputs must be closed after checkOutputForAllStrategies() is executed
+              if (!outputs.isEmpty()) {
+                  for (audio_io_handle_t output : outputs) {
+                      sp<SwAudioOutputDescriptor> desc = mOutputs.valueFor(output);
+                      // close unused outputs after device disconnection or direct outputs that have been
+                      // opened by checkOutputsForDevice() to query dynamic parameters
+                      if ((state == AUDIO_POLICY_DEVICE_STATE_UNAVAILABLE) ||
+                              (((desc->mFlags & AUDIO_OUTPUT_FLAG_DIRECT) != 0) &&
+                               (desc->mDirectOpenCount == 0))) {
+                          closeOutput(output);
+                      }
+                  }
+                  // check A2DP again after closing A2DP output to reset mA2dpSuspended if needed
+                  return true;
+              }
+              return false;
+          });
+        }
 
         if (mEngine->getPhoneState() == AUDIO_MODE_IN_CALL && hasPrimaryOutput()) {
             audio_devices_t newDevice = getNewOutputDevice(mPrimaryOutput, false /*fromCache*/);
-- 
2.7.4

