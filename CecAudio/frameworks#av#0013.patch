From 2decc3d1c75bf3993ac34606d0b8e7575eedf70e Mon Sep 17 00:00:00 2001
From: "hongchao.yin" <hongchao.yin@amlogic.com>
Date: Tue, 22 Oct 2019 16:03:17 +0800
Subject: [PATCH] libaudioprocessing: fixed without adjust the channel [1/1]

PD#SWPL-15218

Problem:
{Marconi}{GTVS}{Android tv APK}Can't record or identify the wrong word
even if recorded.(100%)

Solution:
add upmix and downmix process when 16bit resample

Verify:
verify by x301

Change-Id: Idb554be1cdc3bbfe1858dc9b6375e2be58b7e967
Signed-off-by: hongchao.yin <hongchao.yin@amlogic.com>
---
 media/libaudioprocessing/RecordBufferConverter.cpp | 97 ++++++++++++++++++----
 .../libmedia/include/media/RecordBufferConverter.h |  2 +
 2 files changed, 84 insertions(+), 15 deletions(-)

diff --git a/media/libaudioprocessing/RecordBufferConverter.cpp b/media/libaudioprocessing/RecordBufferConverter.cpp
index 54151f5..7e6bcf6 100644
--- a/media/libaudioprocessing/RecordBufferConverter.cpp
+++ b/media/libaudioprocessing/RecordBufferConverter.cpp
@@ -24,6 +24,7 @@
 #include <media/BufferProviders.h>
 #include <media/RecordBufferConverter.h>
 #include <utils/Log.h>
+#include <cutils/properties.h>
 
 #ifndef ARRAY_SIZE
 #define ARRAY_SIZE(x) (sizeof(x)/sizeof((x)[0]))
@@ -114,8 +115,58 @@ size_t RecordBufferConverter::convert(void *dst,
         // resampler accumulates, but we only have one source track
         memset(mBuf, 0, frames * mBufFrameSize);
         frames = mResampler->resample((int32_t*)mBuf, frames, provider);
-        // format convert to destination buffer
-        convertResampler(dst, mBuf, frames);
+
+        if (useInt16Resampler()) {
+            int32_t* ps32OutData = (int32_t*) mBuf;
+            int16_t* pS16FloatTo16Bit = (int16_t*) malloc(frames * mSrcChannelCount * sizeof(int16_t));
+            int16_t* pS16DstData = NULL;
+            int16_t* pS16UpOrDownMixed = NULL;
+
+            const int volumeShift = 12; // shift requirement for Q4.27 to Q.15
+            // round to half towards zero and saturate at int16 (non-dithered)
+            const int roundVal = (1 << (volumeShift - 1)) - 1; // volumePrecision > 0
+
+            for (size_t i = 0; i < frames; i++) {
+                for (int j = 0; j < (int)mSrcChannelCount; j++) {
+                    int32_t s = ps32OutData[i * mSrcChannelCount + j] + roundVal; // add offset here
+                    if (s < 0) {
+                        s = (s + 1) >> volumeShift; // round to 0
+                        if (s < -32768) {
+                            s = -32768;
+                        }
+                    } else {
+                        s = s >> volumeShift;
+                        if (s > 32767) {
+                            s = 32767;
+                        }
+                    }
+                    pS16FloatTo16Bit[i * mSrcChannelCount + j] = int16_t(s);
+                }
+            }
+
+            if (mIsLegacyDownmix || mIsLegacyUpmix) {
+                pS16UpOrDownMixed = (int16_t*) malloc(frames * mDstChannelCount * sizeof(int16_t));
+            }
+            if (mIsLegacyDownmix) {
+                downmix_to_mono_i16_from_stereo_i16(pS16UpOrDownMixed, pS16FloatTo16Bit, frames);
+                pS16DstData = pS16UpOrDownMixed;
+            } else if (mIsLegacyUpmix){
+                upmix_to_stereo_i16_from_mono_i16(pS16UpOrDownMixed, pS16FloatTo16Bit, frames);
+            } else {
+                pS16DstData = pS16FloatTo16Bit;
+            }
+            memcpy_by_audio_format(dst, mDstFormat, pS16DstData, AUDIO_FORMAT_PCM_16_BIT, frames * mDstChannelCount);
+
+            if (pS16UpOrDownMixed) {
+                free(pS16UpOrDownMixed);
+            }
+            if (pS16FloatTo16Bit) {
+                free(pS16FloatTo16Bit);
+            }
+        } else {
+            // format convert to destination buffer
+            convertResampler(dst, mBuf, frames);
+        }
     }
     return frames;
 }
@@ -162,12 +213,20 @@ status_t RecordBufferConverter::updateParameters(
     mDstChannelCount = audio_channel_count_from_in_mask(dstChannelMask);
     mDstFrameSize = mDstChannelCount * audio_bytes_per_sample(mDstFormat);
 
+    audio_format_t              enResamplerFormat = AUDIO_FORMAT_PCM_FLOAT;
+    AudioResampler::src_quality enResamplerQuality = AudioResampler::DEFAULT_QUALITY;
+    if (useInt16Resampler()) {
+        enResamplerFormat = AUDIO_FORMAT_PCM_16_BIT;
+        enResamplerQuality = AudioResampler::HIGH_QUALITY;
+
+    }
+
     // do we need to resample?
     delete mResampler;
     mResampler = NULL;
     if (mSrcSampleRate != mDstSampleRate) {
-        mResampler = AudioResampler::create(AUDIO_FORMAT_PCM_FLOAT,
-                mSrcChannelCount, mDstSampleRate);
+        mResampler = AudioResampler::create(enResamplerFormat,
+                mSrcChannelCount, mDstSampleRate, enResamplerQuality);
         mResampler->setSampleRate(mSrcSampleRate);
         mResampler->setVolume(AudioMixer::UNITY_GAIN_FLOAT, AudioMixer::UNITY_GAIN_FLOAT);
     }
@@ -200,18 +259,21 @@ status_t RecordBufferConverter::updateParameters(
     // do we need an input converter buffer provider to give us float?
     delete mInputConverterProvider;
     mInputConverterProvider = NULL;
-    if (mRequiresFloat && mSrcFormat != AUDIO_FORMAT_PCM_FLOAT) {
-        mInputConverterProvider = new ReformatBufferProvider(
-                audio_channel_count_from_in_mask(mSrcChannelMask),
-                mSrcFormat,
-                AUDIO_FORMAT_PCM_FLOAT,
-                256 /* provider buffer frame count */);
-    }
 
-    // do we need a remixer to do channel mask conversion
-    if (!mIsLegacyDownmix && !mIsLegacyUpmix && mSrcChannelMask != mDstChannelMask) {
-        (void) memcpy_by_index_array_initialization_from_channel_mask(
-                mIdxAry, ARRAY_SIZE(mIdxAry), mDstChannelMask, mSrcChannelMask);
+    if (!useInt16Resampler()) {
+        if (mRequiresFloat && mSrcFormat != AUDIO_FORMAT_PCM_FLOAT) {
+            mInputConverterProvider = new ReformatBufferProvider(
+                    audio_channel_count_from_in_mask(mSrcChannelMask),
+                    mSrcFormat,
+                    AUDIO_FORMAT_PCM_FLOAT,
+                    256 /* provider buffer frame count */);
+        }
+
+        // do we need a remixer to do channel mask conversion
+        if (!mIsLegacyDownmix && !mIsLegacyUpmix && mSrcChannelMask != mDstChannelMask) {
+            (void) memcpy_by_index_array_initialization_from_channel_mask(
+                    mIdxAry, ARRAY_SIZE(mIdxAry), mDstChannelMask, mSrcChannelMask);
+        }
     }
     return NO_ERROR;
 }
@@ -290,5 +352,10 @@ void RecordBufferConverter::convertResampler(
             frames * mDstChannelCount);
 }
 
+bool RecordBufferConverter::useInt16Resampler() {
+    return (property_get_int32("persist.sys.useint16resampler", 1) == 1) &&
+            (mSrcSampleRate <= 48000);
+}
+
 // ----------------------------------------------------------------------------
 } // namespace android
diff --git a/media/libmedia/include/media/RecordBufferConverter.h b/media/libmedia/include/media/RecordBufferConverter.h
index 2abc45e..151ada5 100644
--- a/media/libmedia/include/media/RecordBufferConverter.h
+++ b/media/libmedia/include/media/RecordBufferConverter.h
@@ -85,6 +85,8 @@ private:
     // format conversion when using resampler; modifies src in-place
     void convertResampler(void *dst, /*not-a-const*/ void *src, size_t frames);
 
+    bool useInt16Resampler();
+
     // user provided information
     audio_channel_mask_t mSrcChannelMask;
     audio_format_t       mSrcFormat;
-- 
1.9.1

