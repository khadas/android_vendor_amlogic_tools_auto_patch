From 2e89675098744c6ee25b7b7ab8eab2824b2f8216 Mon Sep 17 00:00:00 2001
From: "hongchao.yin" <hongchao.yin@amlogic.com>
Date: Tue, 22 Oct 2019 17:21:27 +0800
Subject: [PATCH] libaudioprocessing: fixed without adjust the channel [1/1]

PD#SWPL-15218

Problem:
{Marconi}{GTVS}{Android tv APK}Can't record or identify the wrong word
even if recorded.(100%)

Solution:
add upmix and downmix process when 16bit resample

Verify:
verify by x301

Change-Id: Ie1f71b42e9fe8a4bb16e083276430ee599f3d369
Signed-off-by: hongchao.yin <hongchao.yin@amlogic.com>
---
 media/libaudioprocessing/RecordBufferConverter.cpp | 245 +++++++++------------
 1 file changed, 106 insertions(+), 139 deletions(-)

diff --git a/media/libaudioprocessing/RecordBufferConverter.cpp b/media/libaudioprocessing/RecordBufferConverter.cpp
index 8019393..7e6bcf6 100644
--- a/media/libaudioprocessing/RecordBufferConverter.cpp
+++ b/media/libaudioprocessing/RecordBufferConverter.cpp
@@ -19,12 +19,12 @@
 
 #include <audio_utils/primitives.h>
 #include <audio_utils/format.h>
-#include <cutils/properties.h>
 #include <media/AudioMixer.h>  // for UNITY_GAIN_FLOAT
 #include <media/AudioResampler.h>
 #include <media/BufferProviders.h>
 #include <media/RecordBufferConverter.h>
 #include <utils/Log.h>
+#include <cutils/properties.h>
 
 #ifndef ARRAY_SIZE
 #define ARRAY_SIZE(x) (sizeof(x)/sizeof((x)[0]))
@@ -78,11 +78,9 @@ void RecordBufferConverter::reset() {
 size_t RecordBufferConverter::convert(void *dst,
         AudioBufferProvider *provider, size_t frames)
 {
-    if (!useInt16Resampler()) {
-        if (mInputConverterProvider != NULL) {
-            mInputConverterProvider->setBufferProvider(provider);
-            provider = mInputConverterProvider;
-        }
+    if (mInputConverterProvider != NULL) {
+        mInputConverterProvider->setBufferProvider(provider);
+        provider = mInputConverterProvider;
     }
 
     if (mResampler == NULL) {
@@ -108,65 +106,64 @@ size_t RecordBufferConverter::convert(void *dst,
          ALOGV("RESAMPLING mSrcSampleRate:%u mDstSampleRate:%u mSrcFormat:%#x mDstFormat:%#x",
                  mSrcSampleRate, mDstSampleRate, mSrcFormat, mDstFormat);
 
-         if (useInt16Resampler()) {
-             mBufFrameSize = mDstChannelCount * 4; //fixed-point Q4.27.
-
-             // reallocate buffer if needed
-             if (mBufFrameSize != 0 && mBufFrames < frames) {
-                 free(mBuf);
-                 mBufFrames = frames;
-                 (void)posix_memalign(&mBuf, 32, mBufFrames * mBufFrameSize);
-                ALOGI("%s,posix_memalign,mBufFrames = %d", __FUNCTION__, mBufFrames);
-             }
-             // resampler accumulates, but we only have one source track
-             memset(mBuf, 0, frames * mBufFrameSize);
-             frames = mResampler->resample((int32_t*)mBuf, frames, provider);
-             // format convert to destination buffer
-             // mono takes left channel only (out of stereo output pair)
-             // stereo and multichannel preserve all channels.
-             size_t output_frames = frames;
-             int channels = mSrcChannelCount;
-             size_t output_channels = mDstChannelCount;
-             int32_t* out = (int32_t*) mBuf;
-             int16_t* convert = (int16_t*) malloc(output_frames * channels * sizeof(int16_t));
-
-             const int volumeShift = 12; // shift requirement for Q4.27 to Q.15
-             // round to half towards zero and saturate at int16 (non-dithered)
-             const int roundVal = (1 << (volumeShift - 1)) - 1; // volumePrecision > 0
-
-             for (size_t i = 0; i < output_frames; i++) {
-                 for (int j = 0; j < channels; j++) {
-                     int32_t s = out[i * output_channels + j] + roundVal; // add offset here
-                     if (s < 0) {
-                         s = (s + 1) >> volumeShift; // round to 0
-                         if (s < -32768) {
-                             s = -32768;
-                         }
-                     } else {
-                         s = s >> volumeShift;
-                         if (s > 32767) {
-                             s = 32767;
-                         }
-                     }
-                     convert[i * channels + j] = int16_t(s);
-                 }
-             }
-
-             memcpy_by_audio_format(dst, mDstFormat, convert, AUDIO_FORMAT_PCM_16_BIT,
-                     frames * mDstChannelCount);
-
-             if (convert)
-                 free(convert);
-        } else {//original code
-             // reallocate buffer if needed
-             if (mBufFrameSize != 0 && mBufFrames < frames) {
-                 free(mBuf);
-                 mBufFrames = frames;
-                 (void)posix_memalign(&mBuf, 32, mBufFrames * mBufFrameSize);
-             }
-            // resampler accumulates, but we only have one source track
-            memset(mBuf, 0, frames * mBufFrameSize);
-            frames = mResampler->resample((int32_t*)mBuf, frames, provider);
+         // reallocate buffer if needed
+         if (mBufFrameSize != 0 && mBufFrames < frames) {
+             free(mBuf);
+             mBufFrames = frames;
+             (void)posix_memalign(&mBuf, 32, mBufFrames * mBufFrameSize);
+         }
+        // resampler accumulates, but we only have one source track
+        memset(mBuf, 0, frames * mBufFrameSize);
+        frames = mResampler->resample((int32_t*)mBuf, frames, provider);
+
+        if (useInt16Resampler()) {
+            int32_t* ps32OutData = (int32_t*) mBuf;
+            int16_t* pS16FloatTo16Bit = (int16_t*) malloc(frames * mSrcChannelCount * sizeof(int16_t));
+            int16_t* pS16DstData = NULL;
+            int16_t* pS16UpOrDownMixed = NULL;
+
+            const int volumeShift = 12; // shift requirement for Q4.27 to Q.15
+            // round to half towards zero and saturate at int16 (non-dithered)
+            const int roundVal = (1 << (volumeShift - 1)) - 1; // volumePrecision > 0
+
+            for (size_t i = 0; i < frames; i++) {
+                for (int j = 0; j < (int)mSrcChannelCount; j++) {
+                    int32_t s = ps32OutData[i * mSrcChannelCount + j] + roundVal; // add offset here
+                    if (s < 0) {
+                        s = (s + 1) >> volumeShift; // round to 0
+                        if (s < -32768) {
+                            s = -32768;
+                        }
+                    } else {
+                        s = s >> volumeShift;
+                        if (s > 32767) {
+                            s = 32767;
+                        }
+                    }
+                    pS16FloatTo16Bit[i * mSrcChannelCount + j] = int16_t(s);
+                }
+            }
+
+            if (mIsLegacyDownmix || mIsLegacyUpmix) {
+                pS16UpOrDownMixed = (int16_t*) malloc(frames * mDstChannelCount * sizeof(int16_t));
+            }
+            if (mIsLegacyDownmix) {
+                downmix_to_mono_i16_from_stereo_i16(pS16UpOrDownMixed, pS16FloatTo16Bit, frames);
+                pS16DstData = pS16UpOrDownMixed;
+            } else if (mIsLegacyUpmix){
+                upmix_to_stereo_i16_from_mono_i16(pS16UpOrDownMixed, pS16FloatTo16Bit, frames);
+            } else {
+                pS16DstData = pS16FloatTo16Bit;
+            }
+            memcpy_by_audio_format(dst, mDstFormat, pS16DstData, AUDIO_FORMAT_PCM_16_BIT, frames * mDstChannelCount);
+
+            if (pS16UpOrDownMixed) {
+                free(pS16UpOrDownMixed);
+            }
+            if (pS16FloatTo16Bit) {
+                free(pS16FloatTo16Bit);
+            }
+        } else {
             // format convert to destination buffer
             convertResampler(dst, mBuf, frames);
         }
@@ -216,85 +213,54 @@ status_t RecordBufferConverter::updateParameters(
     mDstChannelCount = audio_channel_count_from_in_mask(dstChannelMask);
     mDstFrameSize = mDstChannelCount * audio_bytes_per_sample(mDstFormat);
 
+    audio_format_t              enResamplerFormat = AUDIO_FORMAT_PCM_FLOAT;
+    AudioResampler::src_quality enResamplerQuality = AudioResampler::DEFAULT_QUALITY;
     if (useInt16Resampler()) {
-        // do we need to resample?
-        delete mResampler;
-        mResampler = NULL;
-        if (mSrcSampleRate != mDstSampleRate) {
-            mResampler = AudioResampler::create(AUDIO_FORMAT_PCM_16_BIT,
-                                                mSrcChannelCount, mDstSampleRate, AudioResampler::HIGH_QUALITY);
-            mResampler->setSampleRate(mSrcSampleRate);
-            mResampler->setVolume(AudioMixer::UNITY_GAIN_FLOAT, AudioMixer::UNITY_GAIN_FLOAT);
-        }
+        enResamplerFormat = AUDIO_FORMAT_PCM_16_BIT;
+        enResamplerQuality = AudioResampler::HIGH_QUALITY;
+
+    }
 
-        // are we running legacy channel conversion modes?
-        mIsLegacyDownmix = (mSrcChannelMask == AUDIO_CHANNEL_IN_STEREO
+    // do we need to resample?
+    delete mResampler;
+    mResampler = NULL;
+    if (mSrcSampleRate != mDstSampleRate) {
+        mResampler = AudioResampler::create(enResamplerFormat,
+                mSrcChannelCount, mDstSampleRate, enResamplerQuality);
+        mResampler->setSampleRate(mSrcSampleRate);
+        mResampler->setVolume(AudioMixer::UNITY_GAIN_FLOAT, AudioMixer::UNITY_GAIN_FLOAT);
+    }
+
+    // are we running legacy channel conversion modes?
+    mIsLegacyDownmix = (mSrcChannelMask == AUDIO_CHANNEL_IN_STEREO
                             || mSrcChannelMask == AUDIO_CHANNEL_IN_FRONT_BACK)
-                           && mDstChannelMask == AUDIO_CHANNEL_IN_MONO;
-        mIsLegacyUpmix = mSrcChannelMask == AUDIO_CHANNEL_IN_MONO
-                         && (mDstChannelMask == AUDIO_CHANNEL_IN_STEREO
-                             || mDstChannelMask == AUDIO_CHANNEL_IN_FRONT_BACK);
-
-        // do we need to process in float?
-        mRequiresFloat = mResampler != NULL || mIsLegacyDownmix || mIsLegacyUpmix;
-
-        // do we need a staging buffer to convert for destination (we can still optimize this)?
-        // we use mBufFrameSize > 0 to indicate both frame size as well as buffer necessity
-        if (mResampler != NULL) {
-            mBufFrameSize = max(mSrcChannelCount, (uint32_t)FCC_2)
-                            * audio_bytes_per_sample(AUDIO_FORMAT_PCM_16_BIT);
-        } else if (mIsLegacyUpmix || mIsLegacyDownmix) { // legacy modes always float
-            mBufFrameSize = mDstChannelCount * audio_bytes_per_sample(AUDIO_FORMAT_PCM_16_BIT);
-        } else if (mSrcChannelMask != mDstChannelMask && mDstFormat != mSrcFormat) {
-            mBufFrameSize = mDstChannelCount * audio_bytes_per_sample(mSrcFormat);
-        } else {
-            mBufFrameSize = 0;
-        }
-        mBufFrames = 0; // force the buffer to be resized.
-
-        // do we need an input converter buffer provider to give us float?
-        delete mInputConverterProvider;
-        mInputConverterProvider = NULL;
-
-    } else { //original code
-        // do we need to resample?
-        delete mResampler;
-        mResampler = NULL;
-        if (mSrcSampleRate != mDstSampleRate) {
-            mResampler = AudioResampler::create(AUDIO_FORMAT_PCM_FLOAT,
-                    mSrcChannelCount, mDstSampleRate);
-            mResampler->setSampleRate(mSrcSampleRate);
-            mResampler->setVolume(AudioMixer::UNITY_GAIN_FLOAT, AudioMixer::UNITY_GAIN_FLOAT);
-        }
+                   && mDstChannelMask == AUDIO_CHANNEL_IN_MONO;
+    mIsLegacyUpmix = mSrcChannelMask == AUDIO_CHANNEL_IN_MONO
+                   && (mDstChannelMask == AUDIO_CHANNEL_IN_STEREO
+                            || mDstChannelMask == AUDIO_CHANNEL_IN_FRONT_BACK);
 
-        // are we running legacy channel conversion modes?
-        mIsLegacyDownmix = (mSrcChannelMask == AUDIO_CHANNEL_IN_STEREO
-                                || mSrcChannelMask == AUDIO_CHANNEL_IN_FRONT_BACK)
-                       && mDstChannelMask == AUDIO_CHANNEL_IN_MONO;
-        mIsLegacyUpmix = mSrcChannelMask == AUDIO_CHANNEL_IN_MONO
-                       && (mDstChannelMask == AUDIO_CHANNEL_IN_STEREO
-                                || mDstChannelMask == AUDIO_CHANNEL_IN_FRONT_BACK);
-
-        // do we need to process in float?
-        mRequiresFloat = mResampler != NULL || mIsLegacyDownmix || mIsLegacyUpmix;
-
-        // do we need a staging buffer to convert for destination (we can still optimize this)?
-        // we use mBufFrameSize > 0 to indicate both frame size as well as buffer necessity
-        if (mResampler != NULL) {
-            mBufFrameSize = max(mSrcChannelCount, (uint32_t)FCC_2)
-                    * audio_bytes_per_sample(AUDIO_FORMAT_PCM_FLOAT);
-        } else if (mIsLegacyUpmix || mIsLegacyDownmix) { // legacy modes always float
-            mBufFrameSize = mDstChannelCount * audio_bytes_per_sample(AUDIO_FORMAT_PCM_FLOAT);
-        } else if (mSrcChannelMask != mDstChannelMask && mDstFormat != mSrcFormat) {
-            mBufFrameSize = mDstChannelCount * audio_bytes_per_sample(mSrcFormat);
-        } else {
-            mBufFrameSize = 0;
-        }
-        mBufFrames = 0; // force the buffer to be resized.
+    // do we need to process in float?
+    mRequiresFloat = mResampler != NULL || mIsLegacyDownmix || mIsLegacyUpmix;
 
-        // do we need an input converter buffer provider to give us float?
-        delete mInputConverterProvider;
-        mInputConverterProvider = NULL;
+    // do we need a staging buffer to convert for destination (we can still optimize this)?
+    // we use mBufFrameSize > 0 to indicate both frame size as well as buffer necessity
+    if (mResampler != NULL) {
+        mBufFrameSize = max(mSrcChannelCount, (uint32_t)FCC_2)
+                * audio_bytes_per_sample(AUDIO_FORMAT_PCM_FLOAT);
+    } else if (mIsLegacyUpmix || mIsLegacyDownmix) { // legacy modes always float
+        mBufFrameSize = mDstChannelCount * audio_bytes_per_sample(AUDIO_FORMAT_PCM_FLOAT);
+    } else if (mSrcChannelMask != mDstChannelMask && mDstFormat != mSrcFormat) {
+        mBufFrameSize = mDstChannelCount * audio_bytes_per_sample(mSrcFormat);
+    } else {
+        mBufFrameSize = 0;
+    }
+    mBufFrames = 0; // force the buffer to be resized.
+
+    // do we need an input converter buffer provider to give us float?
+    delete mInputConverterProvider;
+    mInputConverterProvider = NULL;
+
+    if (!useInt16Resampler()) {
         if (mRequiresFloat && mSrcFormat != AUDIO_FORMAT_PCM_FLOAT) {
             mInputConverterProvider = new ReformatBufferProvider(
                     audio_channel_count_from_in_mask(mSrcChannelMask),
@@ -390,5 +356,6 @@ bool RecordBufferConverter::useInt16Resampler() {
     return (property_get_int32("persist.sys.useint16resampler", 1) == 1) &&
             (mSrcSampleRate <= 48000);
 }
+
 // ----------------------------------------------------------------------------
 } // namespace android
-- 
1.9.1

